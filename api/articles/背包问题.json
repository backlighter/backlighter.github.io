{"title":"背包问题","slug":"背包问题","date":"2018-12-11T13:02:36.000Z","updated":"2018-12-13T10:26:51.459Z","comments":true,"excerpt":"","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><h1 id=\"0-1背包\"><a href=\"#0-1背包\" class=\"headerlink\" title=\"0/1背包\"></a>0/1背包</h1><h2 id=\"蛮力法求解：\"><a href=\"#蛮力法求解：\" class=\"headerlink\" title=\"蛮力法求解：\"></a>蛮力法求解：</h2><p>W[]; v[];背包容量C</p>\n<p>装入背包的物品编号</p>\n<p>1.初始化最大价值MaxValue=0  结果子集S</p>\n<p>2.对集合w[]的每一个子集，执行下述操作</p>\n<p>​    2.1初始化背包的价值value=0;背包的重量,weight=0;</p>\n<p>​    2.2对于子集的每一个元素j</p>\n<p>​        2.2.1如果weight +wj&lt;C 则 weight =weight+wj</p>\n<p>​            value =value +v</p>\n<p>​        否则则转回步骤2考察下一个子集</p>\n<p>​    2.3如果MaxValue 则MaxValue=value;</p>\n<h2 id=\"动态规划求解：\"><a href=\"#动态规划求解：\" class=\"headerlink\" title=\"动态规划求解：\"></a>动态规划求解：</h2><p>​    在实际应用中，经常有这样一类问题：该问题有n个输入，问题的解由这n个输入的一个子集组成，这个子集必须满足某些事先给定的条件，这些条件称为约束条件，满足约束条件的解称为可行解。满足约束条件的可行解可能不只一个，为了衡量这些可行解的优劣，通常以函数的形式给出一定的标准，这些标准函数称为目标函数，使目标函数取得极值的可行解称为最优解，这些问题称为最优化问题。</p>\n<p>​    动态规划法将待求解问题分解成若干相互重叠的子问题，每个问题对应决策过程的一个阶段，一般来说，子问题的重叠关系表现在对给定问题求解的递推关系(称为动态规划函数)中，将子问题的解求解一次并填入表中，将子问题的解求解一次并填入表中，当需要再次求解此问题时，可以通过查表获得此问题的解，从而避免大量计算。具体动态规划法多种多样，但都有相同的填表形式。一般来说，动态规划由以下的三个步骤组成</p>\n<p>​    1.划分子问题：将原问题分解为若干子问题，每个子问题对应一个决策阶段，并且子问题之间具有重叠关系。</p>\n<p>​    2.确定动态规划函数：根据子问题之间的重叠关系找到子问题漫展的递推关系式，这是动态规划法的关键。</p>\n<p>​    3.填写表格：设计表格，以自底向上的方式计算各个子问题的解并填表，实现动态规划过程。</p>\n<p>上述动态规划过程可以求得问题的最优值（即目标函数的极值）,如果要求出具体的最优解，通常在动态规划过程中记录必要的信息，再根据最优决策序列构造最优解。</p>\n<p>`package 算法;</p>\n<p>import java.util.Scanner;</p>\n<p>public class dp01背包 {<br>    static int V[][];</p>\n<pre><code>public static void main(String[] args) {\n    Scanner input = new Scanner(System.in);\n\n    int num = input.nextInt();// 输入应输入多少组数据\n    for (int i = 0; i &lt; num; i++) {\n        int n = input.nextInt();// 输入物品的数量\n        int c = input.nextInt();// 输入背包的容量\n        V = new int[n + 1][c + 1];\n        int w[] = new int[n], v[] = new int[n];// 创建物品的重量和价格\n        for (int j = 0; j &lt; w.length; j++) {\n            w[j] = input.nextInt();\n        }\n        for (int j = 0; j &lt; v.length; j++) {\n            v[j] = input.nextInt();\n        }\n        //System.out.println(knapSack(w, v, n, c));\n        System.out.println(f2(w, v, n, c));\n    }\n\n}\nstatic int f2(int w[],int v[],int n,int c) {\n    for (int i = 0; i &lt;= n; i++) {\n        V[0][i]=0;\n    }\n    for (int i = 0; i &lt;= n; i++) {\n        V[i][0]=0;\n    }\n    for(int i=1;i&lt;=n;i++) {\n        for (int j = 1; j &lt;=c ; j++) {\n            if (w[i-1]&gt;j) {\n                V[i][j]=V[i-1][j];\n            }else {\n                V[i][j]=Math.max(V[i-1][j], V[i-1][j-w[i-1]]+v[i-1]);\n            }\n        }\n    }\n    return V[n][c];\n\n}}`\n</code></pre>","categories":[],"tags":[]}